#!/usr/bin/env perl
#
# use product_deps

package build_table;

use File::Basename;
use lib dirname($0);

use parse_deps;

use strict;
use warnings;

my $inputdir;
my $outputdir;

if( $#ARGV >= 0 ) {
   $inputdir = $ARGV[0];
   if( $#ARGV > 0 ) {
       $outputdir = $ARGV[1];
   } else {
       $outputdir = ".";
   }
} else {
    print "\n";
    print "ERROR: directory not specified\n";
    print "USAGE: build_table <input-directory> [output-directory]\n";
    print "       input-directory  = directory containing product_deps\n";
    print "\n";
    exit 1;
}

$build_table::debug = "false";

my $pfile=$inputdir."/product_deps";

my $tmpfl = $outputdir."/table_diagnostics";
open(TERR, "> $tmpfl") or die "Couldn't open $tmpfl";

my $i;
my $j;

my ($product, $version, $default_ver, $default_qual, $have_fq) = get_parent_info( $pfile );
my ($have_fragment, @flist) = check_for_fragment( $pfile );
my $phash = get_product_list($pfile);
my ($ndeps, @qlist) = get_qualifier_list( $pfile, $build_table::TERR );

print "creating table file for $product $version\n";
print "   default qualifier: $default_qual\n";
print "   default version: $default_ver\n";
if ( $build_table::debug eq "true" ) {
  print "   number of dependencies: $ndeps\n";
  foreach my $dep (keys %{$phash}) {
    foreach my $qual (keys %{$phash->{$dep}}) {
      print " $dep $phash->{$dep}->{$qual}->{version} $qual\n";
    }
  }
  foreach $i ( 0 .. $#qlist ) {
    print "qualifiers  $i:";
    foreach $j ( 1 .. $ndeps ) {
      print " $qlist[$i][$j]";
    }
    print "\n";
  }
}

my $table = "$outputdir/$product.table";
open(TBL, "> $table") or die "Couldn't open $table";
create_table_top();
if ($ndeps and  $qlist[1][0] ne "-nq-") {
  create_quals();
} else {
  no_quals();
}
create_table_bottom();
close(TBL);
close(TERR);

exit 0;



sub create_table_top {
  print TBL "File    = table\n";
  print TBL "Product = $product\n";
  print TBL "\n";
  print TBL "#*************************************************\n";
  print TBL "# Starting Group definition\n";
  print TBL "Group:\n";
  print TBL "\n";
}

sub print_dep_setup_table {
  my ($dep, $dep_info, $dep_quals) = @_;
  my $thisver = ($dep_info->{version} eq "-") ? "" : $dep_info->{version};
  my $setup = ($dep_info->{optional}) ? "Optional" : "Required";
  my $qualstring = ($dep_quals) ?
    sprintf(" -q +\%s", join(":+", split(':', $dep_quals))) : "";
  print TBL "    setup$setup( $dep $thisver$qualstring )\n";
}

sub print_setup {
  my ($prod_quals, $qiter) = @_;
  my $deps = prods_for_quals($phash, $prod_quals);
  foreach my $j ( 1 .. $#{$qlist[$qiter]} ) {
    my $dep = $qlist[0][$j];
    next if $dep eq "compiler";
    my $dep_quals = $qlist[$qiter][$j];
    unless ($dep_quals eq "-" or $dep_quals eq "-b-") {
      my $dep_info = $deps->{$dep} or
        die "Unable to find version info for dependency $dep where dependent's qualifiers are $prod_quals";
      print_dep_setup_table($dep, $dep_info, ($dep_quals eq "-nq-") ? undef : $dep_quals)
        unless $dep_info->{only_for_build};
    }
  }
}

sub no_quals {
  print TBL "Flavor     = ANY\n";
  print TBL "Qualifiers = \"\"\n";
  print TBL "\n";
  print TBL "  Action = GetProducts\n";
  print_setup($qlist[1][0], 1);
  print TBL "\n";
}

sub create_quals {
  foreach my $i ( 1 .. $#qlist ) {
    my $prod_quals = $qlist[$i][0];
    my @words = split(/:/,$prod_quals);
    my $qdot = $prod_quals;
    $qdot =~ s/:/\./g;
    print TBL "Flavor     = ANY\n";
    print TBL "Qualifiers = \"$prod_quals\"\n";
    print TBL "\n";
    if ( $have_fq ) {
      print TBL <<EOF;

  Action = GetFQDir
    if ( printenv CET_SUBDIR > /dev/null )
      envSet( \${UPS_PROD_NAME_UC}_FQ_DIR, \${\${UPS_PROD_NAME_UC}_DIR}/\${CET_SUBDIR}.${qdot} )
    else()
      envSet( \${UPS_PROD_NAME_UC}_FQ_DIR, \${\${UPS_PROD_NAME_UC}_DIR}/\`get-directory-name subdir\`.${qdot} )
    endif ( printenv CET_SUBDIR > /dev/null )
    fileTest( \${\${UPS_PROD_NAME_UC}_FQ_DIR}, -d, \"\${\${UPS_PROD_NAME_UC}_FQ_DIR} directory not found: SETUP ABORTED\")

EOF
    }
    print TBL "  Action = GetProducts\n";
    print_setup($prod_quals, $i);
    print TBL "\n";
  }
}

sub table_ld_library {
  print TBL "    if ( test \`uname\` = \"Darwin\" )\n";
  print TBL "      pathPrepend(DYLD_LIBRARY_PATH, \${\${UPS_PROD_NAME_UC}_LIB})\n";
  print TBL "    else()\n";
  print TBL "      pathPrepend(LD_LIBRARY_PATH, \${\${UPS_PROD_NAME_UC}_LIB})\n";
  print TBL "    endif ( test \`uname\` = \"Darwin\" )\n";
  print TBL "    pathPrepend(CET_PLUGIN_PATH, \${\${UPS_PROD_NAME_UC}_LIB})\n";
}

sub create_table_bottom {

  my $include_directory = get_include_directory( $pfile );
  my $lib_directory = get_lib_directory( $pfile );
  my $fcl_directory = get_fcl_directory( $pfile );
  my $bin_directory = get_bin_directory( $pfile );
  my $def_python_path = get_python_path( $pfile );
  my $fw_directory = get_fw_directory( $pfile );
  my $wp_directory = get_wp_directory( $pfile );
  my $gdml_directory = get_gdml_directory( $pfile );
  my $prl_directory = get_perllib( $pfile );
  my ($fwlen, $fwlist_ref, $fwdir_ref) = get_setfw_list( $pfile );
  my @fwlist=@$fwlist_ref;
  my @fwdirs=@$fwdir_ref;

  my $pvername = $product."_VERSION";
  print TBL "\n";
  print TBL "Common:\n";
  print TBL "  Action = setup\n";
  print TBL "    prodDir()\n";
  print TBL "    setupEnv()\n";
  print TBL "    envSet(\${UPS_PROD_NAME_UC}_VERSION, $version)\n";
  print TBL "    # cetpkgsupport has get-directory-name and find-path\n";
  print TBL "    # cetpkgsupport also defines the CET_SUBDIR variable\n";
  print TBL "    setupRequired(cetpkgsupport)\n";
  if( $have_fq ) {
  print TBL "    exeActionRequired(GetFQDir)\n";
  }
  if( $include_directory eq "default" ) {
  print TBL "    envSet(\${UPS_PROD_NAME_UC}_INC, \${UPS_PROD_DIR}/include) \n";
  } elsif ( $include_directory eq "none" )   {
  } else {
  print TBL "    envSet(\${UPS_PROD_NAME_UC}_INC, $include_directory) \n";
  }
  # need to setup dependencies BEFORE prepending to any paths
  print TBL "\n";
  print TBL "    exeActionRequired(GetProducts)\n";
  print TBL "\n";
  if( $lib_directory eq "default" ) {
    print TBL "    envSet(\${UPS_PROD_NAME_UC}_LIB, \${\${UPS_PROD_NAME_UC}_FQ_DIR}/lib) \n";
    table_ld_library();
    if( $def_python_path ne "none" ) {
      print TBL "    # define PYTHONPATH\n";
      print TBL "    pathPrepend(PYTHONPATH,  \${\${UPS_PROD_NAME_UC}_FQ_DIR}/lib )\n";
    }
    print TBL "\n";
  } elsif ( $lib_directory eq "none" )   {
    if( $def_python_path ne "none" ) {
      print TBL "    # define PYTHONPATH\n";
      print TBL "    pathPrepend(PYTHONPATH, \${\${UPS_PROD_NAME_UC}_FQ_DIR}/lib )\n";
    }
  } else {
  print TBL "    envSet(\${UPS_PROD_NAME_UC}_LIB, $lib_directory) \n";
  table_ld_library();
    if( $def_python_path eq "setme" ) {
      print TBL "    # define PYTHONPATH\n";
      print TBL "    pathPrepend(PYTHONPATH, $lib_directory )\n";
    }
  print TBL "\n";
  }
  if( $bin_directory eq "default" ) {
  print TBL "    # add the bin directory to the path\n";
  print TBL "    pathPrepend(PATH, \${\${UPS_PROD_NAME_UC}_FQ_DIR}/bin )\n";
  print TBL "    # dropit -E removes non-existent directories\n";
  print TBL "    Execute(dropit -E, NO_UPS_ENV, PATH)\n";
  print TBL "\n";
  } elsif ( $bin_directory eq "none" )   {
  } else {
  print TBL "    # add the bin directory to the path\n";
  print TBL "    pathPrepend(PATH, $bin_directory )\n";
  }
  if( $fcl_directory eq "default" ) {
  print TBL "    # add the fcl directory to the fhicl file path\n";
  print TBL "    pathPrepend(FHICL_FILE_PATH, \${UPS_PROD_DIR}/fcl )\n";
  print TBL "\n";
  } elsif ( $fcl_directory eq "none" )   {
  } else {
  print TBL "    # add the fcl directory to the path\n";
  print TBL "    pathPrepend(FHICL_FILE_PATH, $fcl_directory )\n";
  }
  if ( $fw_directory eq "none" )   {
  } else {
  print TBL "    # add $fw_directory to FW_SEARCH_PATH\n";
  print TBL "    pathPrepend(FW_SEARCH_PATH, $fw_directory )\n";
  }
  if ( $wp_directory eq "none" )   {
  } else {
  print TBL "    # add $wp_directory to WIRECELL_PATH\n";
  print TBL "    pathPrepend(WIRECELL_PATH, $wp_directory )\n";
  }
  if( $gdml_directory eq "default" ) {
  print TBL "    # add the gdml directory to FW_SEARCH_PATH\n";
  print TBL "    pathPrepend(FW_SEARCH_PATH, \${UPS_PROD_DIR}/gdml )\n";
  print TBL "\n";
  } elsif ( "$gdml_directory" eq "none" )   {
  } else {
  print TBL "    # add $gdml_directory directory to FW_SEARCH_PATH\n";
  print TBL "    pathPrepend(FW_SEARCH_PATH, $gdml_directory )\n";
  }
  foreach $i ( 0 .. $fwlen ) {
    if( $fwdirs[$i]  eq  "product_dir" ) {
      print TBL "    pathPrepend(FW_SEARCH_PATH, \${UPS_PROD_DIR}$fwlist[$i] )\n";
    } elsif( $fwdirs[$i]  eq  "fq_dir" ) {
      print TBL "    pathPrepend(FW_SEARCH_PATH, \${\${UPS_PROD_NAME_UC}_FQ_DIR}$fwlist[$i] )\n";
    }
  }
  if( $prl_directory eq "default" ) {
  print TBL "    # add the perllib directory to PERL5LIB\n";
  print TBL "    pathPrepend(PERL5LIB, \${UPS_PROD_DIR}/perllib )\n";
  print TBL "\n";
  } elsif ( "$prl_directory" eq "none" )   {
  ##print TBL "    # no perllib directory\n";
  } else {
  print TBL "    # add $prl_directory directory to PERL5LIB\n";
  print TBL "    pathPrepend(PERL5LIB, $prl_directory )\n";
  }
  # CMake directory is determined by whether product is flavour qualified or not
  # If flavour qualified, need to search in fq dir, otherwise in base product_dir
  if( $have_fq ) {
  print TBL "    # Prepend CMAKE_PREFIX_PATH for flavour qualified product\n";
  print TBL "    pathPrepend(CMAKE_PREFIX_PATH, \${\${UPS_PROD_NAME_UC}_FQ_DIR})\n";
  print TBL "    pathPrepend(PKG_CONFIG_PATH, \${\${UPS_PROD_NAME_UC}_FQ_DIR})\n";
    if ( $include_directory ne "none" )   {
    print TBL "    # Prepend ROOT_INCLUDE_PATH for dictionaries\n";
    print TBL "    pathPrepend(ROOT_INCLUDE_PATH, \${\${UPS_PROD_NAME_UC}_INC}) \n";
    }
  } else {
  print TBL "    # Prepend CMAKE_PREFIX_PATH for null flavour product\n";
  print TBL "    pathPrepend(CMAKE_PREFIX_PATH, \${UPS_PROD_DIR} )\n";
  print TBL "    pathPrepend(PKG_CONFIG_PATH, \${UPS_PROD_DIR} )\n";
  }
  print TBL "\n";
  if( $have_fragment ) {
    foreach $i ( 0 .. $#flist ) {
       print TBL "$flist[$i]\n";
    }
  }
  print TBL "End:\n";
  print TBL "# End Group definition\n";
  print TBL "#*************************************************\n";
}
