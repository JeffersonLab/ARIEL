#!/bin/bash
########################################################################
# buildtool
#
# General purpose CMake / build script for packages using cetbuildtools.
#
# Chris Green <greenc@fnal.gov>
#
# 2011/11/10
########################################################################

function real_dir() {
  [[ -n "$1" ]] || return 1
  ( cd "$1" >/dev/null 2>&1 && pwd -P 2>/dev/null; exit $? )
}

function set_vars_from_report_file() {
  type report_product_info >/dev/null 2>&1 || \
    { echo "ERROR: Unable to find report_product_info: source setup_for_development?" 1>&2; exit 1; }
  eval $(report_product_info "${CETPKG_BUILD}" all)
}

# Program name.
prog=${0##*/}

# Usage.
function usage() {
  local exitval
  local long
  if [[ "$1" == "long" ]]; then
    (( long = 1 ))
    shift
  fi
  (( exitval = ${1:-1} ))
  cat 1>&2 <<EOF
usage: ${prog} [<mode-options>] [<misc-options>] [--] [<generator-build-options>]
       ${prog} --help|-h
       ${prog} --usage

Mode options: [-C|--cmake-only|-A|--all|--info] ||
              { [-b|--build] [-i|--install] [-p|--package] [-t|--test] }

Combo options: [-R|--release] || [-T|--test-all]

Misc options: [-D<CMake-definition>]+
              [-E|--export-compile-commands]
              [-G<CMake-generator-string>]
              [-I|--install-prefix <install-location>]
              [--L <label-regex>]
              [--LE <label-regex>]
              [-c|--clean]
              [--clean-logs]
              [--cmake-debug]
              [--cmake-trace]
              [--deleted-header[s] <header>[,<header>]+]
              [-f|--force-top]
              [-g|--graphviz=<dot-file> [--gfilt <gfilt-opt>[,<gfilt-opt>]+]]
              [[--generator <make|ninja>[:<secondary-generator>]]
              [-j #]
              [-l|--log[=<log-file>]|--log-file[=<log-file>]]
              [-q|--quiet]
              [-s|--subdir]
              [--tee]
              [--test-labels|--labels|--test-groups|--groups <group>[<;|,><group>]+]
              [-v|--verbose]

Options suffixed with '+' are repeatable and cumulative. If a
non-repeatable option is specified multiple times, last invocation wins.

The -G and --generator options are mutually-exclusive, and may be specified at most once.

Required environment: CETPKG_BUILD
Optional environment: CETPKG_INSTALL CETPKG_J CETPKG_QUAL
EOF
  (( ${long:-0} )) && cat 1>&2 <<EOF


DETAILS.

Required environment variables:

CETPKG_BUILD:   The build area for the current package.

Optional environment variables:

CETPKG_INSTALL: The default location of the private (or public) UPS
                products area into which to install the package if
                install is requested. This is overridden by -I option,
                but will override existing CMAKE_INSTALL_PREFIX from
                CMake.
CETPKG_J:       Default parallelism for all appropriate steps, assuming
                -j is not specified explicitly.

Other configuration items;

The following items are obtained from the package's
cetpkg_variable_report file, which is generated by sourcing
setup_for_development:

CETPKG_SOURCE:  The source area for the current package (containing the
                top-level CMakeLists.txt).
CETPKG_TYPE:    The build type, required by CMake.
CETPKG_QUAL:    If set, causes -Dqualifier:STRING=\$CETPKG_QUAL to be added
                to the CMake arguments.


MODE OPTIONS.

If any of -A (--all), C (--cmake-only) or --info are set, they override
all other mode options. The cmake-only option overrides the all
option. If any of the other options are selected, they will be executed
in order *after* the CMake stage (which is always executed in the
CETPKG_BUILD directory).

-A
--all

  Execute all targets.

-C
--cmake-only

  Execute *only* the CMake stage.

-b
--build

  Execute the build stage from the current directory. Since this is
  default, this is only required if you specify --install or --package
  and do *not* also specify test (see below).

-i
--install

  Execute the install stage from CETPKG_BUILD. CMake's generated build
  procedure will ensure that all build targets are up to date so the
  explicit build option is deactivated. However, you *may* wish to
  specify --build anyway in the case that you wish to pass arguments to
  the generator procedure for the build phase.

--info

  If already configured (CMake has been run at least once since the last
  clean), give some basic information about the package, then exit.

-p
--package

  Execute the package stage from CETPKG_BUILD to create an install
  tarball. See the notes for --install above regarding the build option.

--short-circuit
--sc

  Execute only the specified targets and not those that might be implied
  (CMake stage, build stage when test stage is specified, etc).

-t
--test

  Execute configured tests with ctest from the current
  directory. Implies --build.


COMBO MODE OPTIONS.

-R
--release

  Equivalent to -t --test-labels=RELEASE.

-T
--test-all

  Equivalent to -t --test-labels=ALL.


MISC. OPTIONS.

-D<CMake-definition>

  Pass definitions to the invocation of the CMake stage. A warning shall
  be issued if this option is specified but the CMake stage is not to be
  executed.

-E
--export-compile-commands

  Equivalent to -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON. Useful for
  (e.g.) clang-tidy.

-G<CMake-generator-string>

  Pass the specified CMake generator string through to CMake. Note that,
  at this time, only the "Unix Makefiles" and Ninja generators are
  supported by buildtool. Any secondary generator specification is
  passed through unexamined.

-I <ups-install-dir>
--install-prefix <ups-install-dir>

  Specify the location of the private (or public) UPS products area into
  which to install the package if install is requested. Overrides the
  CETPKG_INSTALL environment variable and anything already known to
  CMake.

--L <label-regex>
--LE <label-regex>

  Per CTest, include (--L) or exclude (--LE) labels by CMake regex. Both
  options are mutually exclusive with --test-labels, -T and -R, but not
  with each other. Specifying one of these options implies -t.

-c
--clean

  Remove CMake-generated files and caches and other build products.

--clean-logs

  Remove .log files in the \${CETPKG_BUILD} top directory.

--cmake-debug

  Add --debug-output to the CMake command line options.

--cmake-trace

  Add --trace to the CMake command line options.

--deleted-header[s] <header>[,<header>]+

  Indicate that named headers have been removed from the source, to
  allow removal and regeneration of dependency files containing
  references to same.

--force-top

  Force build and test stages (if applicable) to take place in the top
  level \${CETPKG_BUILD} area (default is to build / test in current
  directory). Note that the configuration stage *always* takes place in
  \${CETPKG_BUILD}. --force-top is implied for the ninja generator at
  build stage, and is incompatible with --subdir.

-g <dot-file>
--graphviz <dot-file>

  Ask CMake to produce a code dependency graph in graphviz (.dot) format.

  Note that CMake can only tell you about the dependencies about which
  it knows. Libraries must have their dependencies resolved at library
  production time (NO_UNDEFINED) in order for the information to be
  complete.

--gfilt[=<opt>[,<opt>]+]

  Filter the graphviz output from CMake through cmake-graphviz-filt,
  with the following options:

    exes|no-exes

      With or without executables shown (default without).

    dicts|no-dicts

      With or without dictionary and map libraries (default without).

    extlibs|no-extlibs

      With or without extlibs shown (default without).

    short-libnames|no-short-libnames

      Any fully-specified library pathnames are shortened to their
      basenames (default long).

    test-tree|no-test-tree

      With or without libraries and execs from the test directory
      hierarchy (default without).

    tred|no-tred

      With or without transitive dependency reduction (default with).

  Multiple options should be comma-separated. Note that all of these
  options may be specified in ~/.cgfrc for the same effect (command-line
  overrides).

--generator <generator>[:<secondary-generator>]

  Use the specified generator. Currently supported values are "make" and
  "ninja" (default make). If an optional secondary generator (e.g.
  CodeBlocks) is specified it will be passed through unchanged.

-h|--help

  This help (long-form).

-j #

  Specify the level of parallelism for stages for which it is
  appropriate (overrides CETPKG_J if specified).

-l
--log[=<log-file>]
--log-file[=<log-file>]

  All build output is redirected to the specified log-file, or one with
  a default name if no other is specified. Unless --quiet is also
  specified, stage information will still be printed to the screen,
  though see --tee below. Note that the short variant does not accept an
  argument: a log-file name will be generated. The long forms should use
  "=" to separate the option from its argument.

-q
--quiet

  Suppress all non-error output to the screen (but see --tee below). A
  log file will still be written as normal if so specified.

-s <subdir>
--subdir <subdir>

  Build (or test) only targets in and under <subdir>, which will be
  interpreted relative to \${CETPKG_BUILD}. If the make generator is
  selected, the make is executed from inside the specified directory. If
  the ninja generator is selected, the appropriate list of targets is
  specified to ninja in addition to any targets specified on the command
  line by the user. Incompatible with --force-top.

--tee

  Write to a log file (either as specified by --log or the default), but
  copy output to the screen also: --quiet is overridden by this option.

--test-labels <group>[<;|,><group>]+
--labels <group>[<;|,><group>]+
--test-groups <group>[<;|,><group>]+
--groups <group>[<;|,><group>]+

  Specify optional CMake test labels to execute. Since cetbuildtools
  v6_00_00, this is integrated with the CMake labels facility, and the
  test selection is done at CTest invocation time rather than CMake time
  as previously. If this option is activated but tests are not to be
  run, a warning shall be issued. If no labels are selected, then
  DEFAULT is selected. A value of ALL is substituted with all known test
  labels. A leading \`-' for a label will lead to its explicit
  exclusion. See also -T, -R options. Mutually-exclusive with --L and
  --LE options.

--usage

  Short help.

-v
--verbose

  Extra information about the commands being executed at each step


EXAMPLES.

Build, test, install and create a package tarball from scratch with
output to a default-named log file, using parallelism:

  $prog -A -c -l -I <install-dir> -j16

As above, but copying output to screen:

  $prog -A -c -l --tee -I <install-dir> -j16

The need for the -I option may be obviated by defining CETPKG_INSTALL;
the need for the explicit parallelism may be similarly voided by
defining (eg) CETPKG_J=16.

To build a particular target only (e.g. for make):

  buildtool --subdir art/Framework/IO/Root -- RootOutput_source.o

To build and test only:

  buildtool -t -j16

To install and package only:

  buildtool -i -p -j16
EOF

  exit ${exitval}
}

# Obtain a given CMake variable.
function cmake_var() {
  ( cd "$CETPKG_BUILD" && cmake -N -L | grep -e '^'"$1"':' | cut -d= -f2- ) 2>/dev/null
}
# Obtain a given CMake system variable.
function cmake_sys_var() {
  ( cd "$CETPKG_BUILD" && cmake -N --system-information | grep -e '^'"$1"':' | cut -d= -f2- ) 2>/dev/null
} 

function package_name() {
    echo "$(cmake_var product)"
}

function package_version() {
  echo "$(cmake_var VERSION_MAJOR).$(cmake_var VERSION_MINOR).$(cmake_var VERSION_PATCH)"
}

function cmake_to_bash_list() {
  local OIFS=$IFS
  IFS=\;
  bash_list=(${@})
  IFS=$OIFS
}

function package_test_labels() {
  cmake_var CET_DEFINED_TEST_GROUPS
}

function basic_info() {
  if [[ -n $(package_name) ]]; then
    cat <<EOF
Package info:           $(package_name) $(package_version)
Build type:             $(cmake_var CMAKE_BUILD_TYPE)
Qualifier:              $(cmake_var qualifier)
EOF
    cmake_to_bash_list "$(package_test_labels)"
    local defined_test_labels="${bash_list[@]}"
    [[ -n "{$defined_test_labels[@]}" ]] && \
      cat <<EOF
Known test groups:      ${defined_test_labels[@]}
EOF
    exit 0
  else
    echo "ERROR: CMake not run; no current information in build area." 1>&2
    exit 1
  fi
}

function package_info() {
  local package_name=$(package_name)
  local package_version=$(package_version)
  [[ -n "$package_name" ]] && [[ -n "$package_version" ]] || return
  local msg="INFO: $package_name version $package_version configured."
  local test_labels="$(package_test_labels)"
  [[ -n "$test_labels" ]] && \
    msg="${msg}
      Available test groups: ${test_labels}."
  (( ${redirected:-0} )) && printf -- "$msg\n" 1>&3
}

# Banner line
function banner() {
  (( ${quiet:-0} )) && return
  if [[ -n "$2" ]]; then
    local redir="1>&$1"
    shift
  fi
  eval cat $redir <<EOF

------------------------------------
$1
------------------------------------

EOF
}

function log_no_tee() {
  [[ -n "$log" ]] && (( ! ${tee:-0} ))
}

function writeStuff() {
  printf -- "$*\n"
  (( ${redirected:-0} )) && printf -- "$*\n" 1>&3
}

function report() {
  writeStuff "$*"
}

function verbose() {
  (( ${do_verbose:-0} )) && writeStuff "VERBOSE: $*"
}

function cmd() {
  while getopts :d: OPT; do
    case $OPT in
      d)
        local desc="$OPTARG"
        ;;
      *)
        error "INTERNAL ERROR: check buildtool's use of cmd function."
        exit 1
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1
  (( ${do_verbose:-0} )) && writeStuff "CWD: $(pwd -P)\nCOMMAND: $*${desc+\nDESCRIPTION: ${desc}}"
  SECONDS=0
  "$@"
  local status=$?
  (( ${do_verbose:-0} )) && writeStuff "$(printf "TIME ELAPSED: %d:%02d\n" $((${SECONDS} / 60)) $((${SECONDS} % 60)))"
  return ${status}
}

function error() {
  local errmsg="$*"
  printf -- "$errmsg\n\n" 1>&2
  (( ${redirected:-0} )) && printf -- "$errmsg\n" 1>&4
}

# Check status and exit if necessary
function check_status() {
  local status=$?
  if [[ -n "$1" ]]; then # Override
    status=$1
  fi
  if (( status == 0 )); then
    banner "INFO: Stage $stage successful."
    (( ${redirected:-0} )) && \
        echo "INFO: Stage $stage successful." 1>&3
  else
    banner 2 "ERROR: Stage $stage failed."
    (( ${redirected:-0} )) && \
        echo "ERROR: Stage $stage failed with code $status: see $log for details." 1>&4
    exit $status
  fi
  return $status
}

# Announce the next stage.
function announce_stage() {
  banner "INFO: Stage $stage${@}."
  if (( ${redirected:-0} )); then
    echo "INFO: Stage $stage${@}." 1>&3
  fi
}

function check_curdir_in_build_tree() {
  if [[ $(real_dir .) != $(real_dir "$CETPKG_BUILD")* ]]; then
    error "INFO: current directory $(real_dir .) is not in the current build tree
         ($(real_dir "$CETPKG_BUILD")). Executing stage $stage from \$CETPKG_BUILD."
    cd "$(real_dir "$CETPKG_BUILD")"
  fi
}

function maybe_force_top_and_announce() {
  if [[ $(real_dir .) == $(real_dir "$CETPKG_BUILD")/* ]]; then
    if (( ${force_top:-0} )) || \
       { [[ "${stage}" == build ]] && [[ "${generator}" == ninja ]]; }; then
      cd "$(real_dir "$CETPKG_BUILD")"
      if (( ${force_top:-0} )); then
        local reason="--force-top"
      else
        local reason="generator requirements"
      fi
      announce_stage " in $(real_dir .) per ${reason}"
    else
      local msg
      [[ -n "${subdir}" ]] || msg=" (--force-top to override)"
      announce_stage " in $(real_dir .)${msg}"
    fi
  else
    announce_stage
  fi
}

# Clean up
function restore_output_streams() {
  if (( ${redirected:-0} )); then
    exec 2>&4- 1>&3-
  fi
}

function cleanup() {
  [[ -n "$TMP" ]] && [[ -d "$TMP" ]] && rm -rf "$TMP"
}

declare -a deleted_headers

# Deleted headers.
function add_deleted_headers() {
  local oifs="$IFS"
  IFS=","
  for file in $1; do
    deleted_headers[${#deleted_headers[@]}]=$file
  done
  IFS="$oifs"
}

# Delete references to deleted headers.
function find_and_remove_deleted_header_refs() {
  eval grep -Z -l -I -F -w \
       -r $(for file in "${deleted_headers[@]}"; do
            printf -- "${file+-e '$file' }"; done) . | \
    while read -r -d $'' ff; do
      grep -q -I -e '^INFO: buildtool log started' "$ff" || rm -fv "$ff"
    done
}

# Funky argument parsing.
function process_gfargs() {
  local oifs="$IFS"
  IFS=,
  for opt in $1; do
    case $opt in
      dicts|no-dicts|exes|no-exes|extlibs|no-extlibs|short-libnames|no-short-libnames|test-tree|no-test-tree)
        gfargs[${#gfargs[@]}]=--${opt};
      ;;
      tred)
        (( tred = 1 ))
      ;;
      no-tred)
        unset tred
        :
      ;;
      *)
        echo "Unrecognized gfilt option \"$opt\"" 1>&2
        usage 1
    esac
  done
  IFS="$oifs"
}

function reorder_quals() {
  printf -- "$1" | tr ':' '\n' | sort | tr '\n' ':' | sed -e 's/:$//'
}

function label_regex() {
  if (( $# )); then
    ans='^('
    for label in "${@}"; do
      ans="${ans}${label}|"
    done
    ans="${ans%|})\$"
    printf "${ans}"
  fi
}

function test_spec_args() {
  tsargs=()
  if [[ -n "${test_labels}" ]]; then
    cmake_to_bash_list "${test_labels}"
    local l=()
    local le=()
    for label in "${bash_list[@]}"; do
      if [[ "$(echo "${label#-}" | tr '[a-z]' '[A-Z]')" = "ALL" ]]; then
        # Short-circuit
        tsargs=()
        return
      fi
      if [[ "${label}" == -* ]]; then
        le+=("${label#-}")
      else
        l+=("${label}")
      fi
      local l_regex=$(label_regex "${l[@]}")
      local le_regex=$(label_regex "${le[@]}")
    done
  fi
  tsargs=(${l_regex:+-L "${l_regex}"} ${le_regex:+-LE "${le_regex}"})
  (( ${#tsargs[@]} == 0 )) && tsargs=(-L '^DEFAULT$')
}

# Main work
function do_work() {
  local real_subdir
  if log_no_tee; then
    report "INFO: Redirecting output to $log"
    exec 3>&1 4>&2 >"$log" 2>&1
    report "INFO: buildtool log started at $(date)"
    (( redirected = 1 ))
    trap "restore_output_streams; cleanup" EXIT
  fi
  stage=cmake
  if (( ${short_circuit:-0} && ! ${cmake_only:-0} )); then
    announce_stage " SKIPPED per --short-circuit"
    if [[ -n "${cmake_defs}" ]]; then
      error "WARNING: CMake definitions ignored since CMake not invoked: ${cmake_defs}"
    fi
    if [[ -n "${cmake_debug}" ]] || \
      [[ -n "${cmake_trace}" ]] || \
      [[ -n "${cmake_defs}" ]] || \
      [[ -n "${generator_arg}" ]]; then
      error "WARNING: CMake options ignored since CMake not invoked:" \
            ${cmake_defs+${cmake_defs} } \
            ${cmake_debug+${cmake_debug} } \
            ${cmake_trace+${cmake_trace} } \
            ${generator_arg+${generator_arg}}
    fi
  else
    announce_stage
    # Where definitions include comma-delimted lists, turn them into
    # CMake's list delimiter instead.
    cmake_defs=${cmake_defs//,/;}
    [[ -n "${CETPKG_CC}" ]] && \
        local ccenv="CC=${CETPKG_CC} CXX=${CETPKG_CXX} FC=${CETPKG_FC}"
    export deleted_headers
    ( cd "$CETPKG_BUILD" && \
        { (( ${#deleted_headers[@]} )) &&
            [[ -d CMakeFiles ]] &&
            cmd -d "Remove references to deleted headers." \
              find_and_remove_deleted_header_refs
          cmd -d "Execute CMake." \
            eval ${ccenv} cmake ${cmake_debug} ${cmake_trace} \
            -DCMAKE_INSTALL_PREFIX="$install_prefix" \
            -DCMAKE_BUILD_TYPE=${CETPKG_TYPE} \
            ${garg} ${cmake_defs}${generator_arg} ${CETPKG_SOURCE}
        }
    ) || check_status # Fail here if there's a problem.
    export -n deleted_headers
    if [[ -f "${gtmpfile}" ]]; then
      if (( ${gfilt:-0} )); then
        if (( ${tred:-0} )); then
          cat "${gtmpfile}" | cmake-graphviz-filt "${gfargs[@]}" | tred > "${gfile}"
        else
          cat "${gtmpfile}" | cmake-graphviz-filt "${gfargs[@]}" > "${gfile}"
        fi
      else
        mv "${gtmpfile}" "${gfile}"
      fi
    fi
    check_status
    package_info
    if (( ${clean:-0} )) && [[ -d "${install_prefix}" ]]; then
      # Removing installed flavorqual-specific files.
      local fq_dir="$(cmake_var flavorqual_dir)"
      if [[ -n "${fq_dir}" ]] && [[ -d "${install_prefix}/${fq_dir}" ]]; then
        fq_dir="${install_prefix}/${fq_dir}"
        report "INFO: Cleaning flavor-specific install dir \"${fq_dir}\""
        rm -rf "${fq_dir}"
      fi
    fi
    (( ${cmake_only:-0} )) && exit 0
  fi

  if (( ${do_build:-0} == 1 || ( ${do_build:-0} > 1 && ! ${short_circuit:-0} ) )); then
    stage=build
    if [[ -n "${subdir}" ]]; then
      real_subdir=$(real_dir "${CETPKG_BUILD}/${subdir}")
      if (( $? )); then
        echo "ERROR: Unable to verify validity of specified subdirectory: ${subdir}." 1>&2
        exit 1
      fi
      if [[ "${generator}" != ninja ]]; then
        cd "${real_subdir}" || \
          { echo "ERROR: unable to cd to specified subdirectory: ${subdir}." 1>&2
          exit 1; }
      fi
    fi
    maybe_force_top_and_announce
    check_curdir_in_build_tree
    if [[ -n "${subdir}" ]] && [[ "${generator}" == ninja ]]; then
      local target=${subdir:+${subdir}/all}
    fi
    cmd -d "Execute build. " time ${generator} ${jarg} "$@" ${target}
    check_status
  fi

  if (( ${do_test:-0} )); then
    stage=test
    if [[ -n "${subdir}" ]] && [[ -z "${real_subdir}" ]]; then
      real_subdir=$(real_dir "${CETPKG_BUILD}/${subdir}")
      if (( $? )); then
        echo "ERROR: Unable to verify validity of specified subdirectory: ${subdir}." 1>&2
        exit 1
      fi
    fi
    if [[ -n "${real_subdir}" ]]; then
      cd "${real_subdir}" || \
        { echo "ERROR: unable to cd to specified subdirectory: ${subdir}." 1>&2
        exit 1; }
    fi
    maybe_force_top_and_announce
    check_curdir_in_build_tree
    test_spec_args
    # Trap and tee *only* stderr from ctest. Yes, this is fiddly.
    exec 5>&1
    { cmd -d "Execute tests." \
      ctest $jarg "${tsargs[@]}" 2>&1 >&5 5>&-
      echo $? > "$TMP/status.dat"
    } | \
     tee "$TMP/ctest.err" 5>&-
    exec 5>&-
    local status
    (( status = $(cat "$TMP/status.dat") ))
    if (( status == 0 )) && [[ -s "$TMP/ctest.err" ]]; then
      err=$(cat "$TMP/ctest.err")
      if (( $(echo "$err" | wc -l) == 1 )) && \
         [[ "$err" == "No tests were found!!!" ]]; then
        # If this is the only output, then chances are there were no tests.
       check_status $status
      else
        error "\nERROR: Detected stderr output from ctest."
        check_status 1
      fi
    else
      check_status $status
    fi
  elif [[ -n "${test_labels}${l_regex}${le_regex}" ]]; then
    test_specs="${test_labels:+--test-labels ${test_labels}}"
    if [[ -z "${test_specs}" ]]; then
      test_specs="${l_regex:+--L \"${l_regex}\"}"
      [[ -n "${le_regex}" ]] && test_specs="${test_specs:+${test_specs} }--LE \"${le_regex}\""
    fi
    error "WARNING: test label specifications ${test_specs} ignored since tests are not enabled."
  fi

  if [[ -n "$targets" ]]; then
    stage="install / package"
    announce_stage
    ( cd "$CETPKG_BUILD" && cmd -d "Install / package." ${generator} $jarg $targets )
    check_status
  fi
}

function ensure_unique_gen() {
  if (( ${#seen_gen_arg[@]} > 0 )); then
    error "Only one generator specifcation argument is permitted: user specified:\n" \
          "${seen_gen_arg[@]} and\n" \
          "${@}"
  fi
  seen_gen_arg=("${@}")
}

# Defaults.
log_default="build_`date \"+%Y-%m-%d\"`.log"
(( tred = 1 ))

# Temporary directory.
TMP=`mktemp -d ${TMPDIR:-/tmp}/buildtool.XXXXXXXXXX`
if [[ -z "$TMP" ]]; then
  echo "ERROR: Unable to create temporary working directory: aborting buildtool execution." 1>&2
  exit 1
fi

# Parse arguments.
getopt -T >/dev/null 2>&1
if (( $? != 4 )); then
  echo "ERROR: GNU getopt required! Check SETUP_GETOPT and PATH." 1>&2
  exit 1
fi

TEMP=`getopt -n "$prog" --long L:,LE:,all,cmake-debug,cmake-only,cmake-trace,install-prefix:,build,clean,clean-logs,deleted-header:,deleted-headers:,export-compile-commands,force-top,generator:,graphviz:,gfilt::,groups:,help,info,install,labels:,log::,log-file::,package,quiet,sc,short-circuit,subdir:,tee,test,test-all,test-labels:,test-groups:,release,usage,verbose -o +ACD:EG:I:RTbcfg:hij:lpqs:tv -- "${@}"`

if (( $? )); then
  usage 1
fi

if [[ -n "$CETPKG_J" ]]; then
  jarg="-j$CETPKG_J"
fi

eval set -- "$TEMP"
while true; do
  case $1 in
    -A|--all)
      (( all = 1 ))
      shift
      ;;
    -C|--cmake-only)
      (( cmake_only = 1 ))
      shift
      ;;
    -D)
      cmake_defs="${cmake_defs}${1}${2} "
      shift
      shift
      ;;
    -E)
      cmake_defs="${cmake_defs}-DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON "
      shift
      ;;
    -G)
      ensure_unique_gen "${@}"
      shift
      case ${1##*- } in
        "Unix Makefiles")
          generator=make
          ;;
        Ninja)
          generator=ninja
          ;;
        *)
          error "ERROR: Unrecognized primary generator ${1##*- }."
          exit 1
      esac
      generator_arg="-G\"${1}\""
      shift
      ;;
    -I|--install-prefix)
      install_prefix=$2
      (( set_install_prefix = 1 ))
      shift
      shift
      ;;
    --L)
      l_regex=$2
      shift
      shift
      set -- -t "${@}"
      ;;
    --LE)
      le_regex=$2
      shift
      shift
      set -- -t "${@}"
      ;;
    -R|--release)
      shift
      set -- -t --test-labels RELEASE "${@}"
      ;;
    -T|--test-all)
      shift
      set -- -t --test-labels ALL "${@}"
      ;;
    -b|--build)
      (( do_build = 1 ))
      shift
      ;;
    --clean-logs)
      (( clean_logs = 1 ))
      shift
      ;;
    -c|--clean)
      (( clean = 1 ))
      shift
      ;;
    --cmake-debug)
      cmake_debug=--debug-output
      shift
      ;;
    --cmake-trace)
      cmake_trace=--trace
      shift
      ;;
    --deleted-header|--deleted_headers)
      shift
      [[ -n "$1" ]] && add_deleted_headers "$1"
      shift
      ;;
    -f|--force-top)
      (( force_top = 1 ))
      shift
      ;;
    -g|--graphviz)
      gfile=${2}
      gtmpfile="$TMP/$(basename $2)"
      garg="--graphviz=$gtmpfile"
      shift; shift;
      ;;
     --gfilt)
      (( gfilt = 1 ))
      shift
      if [[ -n "$1" ]]; then
        declare -a gfargs
        process_gfargs "${1}"
      fi
      shift
      ;;
     --generator)
      ensure_unique_gen "${@}"
      shift
      generator=${1%%:*}
      [[ "${generator}" != "${1}" ]] && secondary_generator=${1#*:}
      case $generator in
        make)
            generator_arg="Unix Makefiles"
            ;;
        ninja)
            generator_arg=Ninja
            ;;
        *)
          error "ERROR: Unrecognized primary generator ${1}."
          exit 1
      esac
      generator_arg="-G\"${secondary_generator:+${secondary_generator} - }${generator_arg}\""
      shift
      ;;
    -h|--help)
      usage long
      shift
      ;;
    -i|--install)
      (( no_build = 1 ))
      targets="$targets install"
      shift
      ;;
    --info)
      (( want_info = 1 ))
      shift
      ;;
    -j)
      jarg="-j$2"
      shift
      shift
      ;;
    -l)
      log="${log_default}"
      shift
      ;;
    --log|--log-file)
      shift
      if [[ -d "$1" ]]; then
        log="$1/${log_default}"
      else
        log="${1:-${log:-${log_default}}}"
      fi
      shift
      ;;
    -p|--package)
      (( no_build = 1 ))
      targets="$targets package"
      shift
      ;;
    -q|--quiet)
      (( quiet = 1 ))
      shift
      ;;
    -s|--subdir)
      subdir="${2}"
      shift
      shift
      ;;
    --short-circuit|--sc)
      (( short_circuit = 1 ))
      shift
      ;;
    -t|--test)
      (( do_build = 2 )) # May be overridden by ${short_circuit}.
      (( do_test = 1 ))
      shift
      ;;
    --tee)
      log="${log:-${log_default}}"
      (( tee = 1 ))
      shift
      ;;
    --test-labels|--labels|--test-groups|--groups)
      test_labels="${test_labels:+${test_labels};}${2//,/;}"
      shift
      shift
      ;;
    --usage)
      usage
      shift
      ;;
    -v|--verbose)
      (( do_verbose = 1 ))
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      echo "Bad argument $1" 1>&2
      usage 1
  esac
done

# Basic safety checks.
if [[ -z "$CETPKG_BUILD" ]]; then
  echo "ERROR: Expected CETPKG_BUILD and friends to be set: source setup_for_development?" 1>&2
  exit 1
elif [[ ! -d "$CETPKG_BUILD" ]] || [[ ! -w "$CETPKG_BUILD" ]]; then
  echo "ERROR: CETPKG_BUILD \"$CETPKG_BUILD\" does not exist,
       is not a directory or is not writable." 1>&2
  exit 1
elif [[ $(real_dir "$CETPKG_BUILD") == $(real_dir "$CETPKG_SOURCE") ]]; then
  echo "ERROR: CETPKG_BUILD ($CETPKG_BUILD) is identical to
       CETPKG_SOURCE (${CETPKG_SOURCE})." 1>&2
  exit 1
elif [[ $(real_dir "$CETPKG_BUILD") == $(real_dir "$CETPKG_SOURCE")/* ]]; then
  echo "ERROR: CETPKG_BUILD ($CETPKG_BUILD) is a subdir of
       CETPKG_SOURCE (${CETPKG_SOURCE})." 1>&2
  exit 1
elif [[ $(real_dir "$CETPKG_SOURCE") == $(real_dir "$CETPKG_BUILD")/* ]]; then
  echo "ERROR: CETPKG_SOURCE ($CETPKG_SOURCE) is a subdir of
       CETPKG_BUILD (${CETPKG_BUILD})." 1>&2
  exit 1
elif [[ -f "${CETPKG_BUILD}/CMakeLists.txt" ]]; then
   echo "ERROR: CETPKG_BUILD (${CETPKG_BUILD}) has a CMakeLists.txt file:
       also a source area?" 1>&2
   exit 1
elif [[ "$CETPKG_BUILD" == "/" ]]; then
  echo "ERROR: CETPKG_BUILD == /" 1>&2
  exit 1
elif [[ "$CETPKG_BUILD" != /* ]]; then
  echo "ERROR: CETPKG_BUILD appears to be relative." 1>&2
  exit 1
elif [[ $(real_dir "$CETPKG_BUILD") == "${HOME}" ]] || \
     [[ $(real_dir "$CETPKG_BUILD") == ~ ]]; then
  echo "ERROR: CETPKG_BUILD has been set to your home directory." 1>&2
  exit 1
fi

set_vars_from_report_file

if [[ -z "$CETPKG_SOURCE" ]] || \
    [[ -z "$CETPKG_TYPE" ]] || \
    [[ -z "$CETPKG_CC" ]] || \
    [[ -z "$CETPKG_CXX" ]] || \
    [[ -z "$CETPKG_FC" ]]; then
  echo "ERROR: Missing required variable from cetpkg_variable_report: cetbuildtools version mismatch?" 1>&2
  exit 1
fi

# Argument consistency checks
if (( ${clean:-0} )) && [[ -n "${MRB_BUILDDIR}" ]]; then
  echo "ERROR: MRB environment detected. Use mrb z; mrb setenv instead of buildtool (or mrb b) --clean" 1>&2
  exit 1
fi

if (( ${force_top:-0} )) && [[ -n "${subdir}" ]]; then
    echo "ERROR: specifying --force-top and --subdir together is not meaningful." 1>&2
    exit 1
fi

if [[ -n "${test_labels}" ]] && \
   { [[ -n "${l_regex}" ]] || [[ -n "${le_regex}" ]]; }; then
  echo "ERROR: --LE and --L are mutually-exclusive with -T, -R, and --test-labels and synonyms." 1>&2
  exit 1
fi

# If desired, print current build information and quit.
if (( ${want_info:-0} )); then
  basic_info # Will exit.
fi

# Make sure output will appear as we'd like.
if (( ${tee:-0} )); then
  # You asked for stuff to the screen -- that's what you'll get.
  echo "WARNING: --tee option overrides --quiet." 1>&2
  unset quiet
fi

# If you're logging to file (but not using tee) we don't want quiet.
if log_no_tee; then
  unset quiet
fi

# Did we specify all?
if (( ${all:-0} )); then
  (( do_build = 1 ))
  (( do_test = 1 ))
  targets="install package"
else
  # In general, build unless we've been asked not to where that is
  # compatible with our other options.
  (( do_build = ${do_build:-0} | ! ${no_build:-0} ))
fi

# Possibly clean up.
if (( ${clean:-0} )); then
  if [[ $(real_dir .) == $(real_dir "$CETPKG_BUILD")/* ]]; then
    echo "ERROR: Clean operation would remove the current directory!" 1>&2
    exit 2
  fi
  if (( $(ls -1 "${CETPKG_BUILD}" | wc -l) )) && ! [[ -f "${CETPKG_BUILD}/cetpkg_variable_report" ]]; then
    echo "ERROR: Refusing to clean suspect non-empty build directory \"${CETPKG_BUILD}\"" 1>&2
    echo "       Double-check value and contents of \$CETPKG_BUILD." 1>&2
    exit 2
  fi
  trap "f=$?; printf -- \"\nAborted\n\" 1>&2; cleanup; exit $f" 2
  printf -- "INFO: About to clean \"$CETPKG_BUILD\": ctrl-C to abort within 5 seconds "
  for i in 1 2 3 4 5; do printf -- "."; sleep 1; done
  printf -- "\n";
  pushd /tmp >/dev/null # 2>&1
  report "INFO: Cleaning \"$CETPKG_BUILD\""
  if ! { find "$CETPKG_BUILD" -mindepth 1 -maxdepth 1 \
         \( -type d -o -name '*.cmake' -o -name 'CMakeCache.txt' -o -name 'Makefile' \) -print | \
         xargs rm -rf; }; then
    echo "ERROR: Unable to clean directory \"$CETPKG_BUILD\"" 1>&2
    exit 2
  fi
  popd >/dev/null || cd "$CETPKG_BUILD" # 2>&1
  trap 2
  if (( ${short_circuit:-0} )); then
    exit 0
  fi
else # Check consistency.
  # product_deps is read and acted upon during source of
  # setup_for_development. If it's changed since then, we have a
  # problem.
  if [[ "$CETPKG_SOURCE/ups/product_deps" -nt "$CETPKG_BUILD/cetpkg_variable_report" ]]; then
    printf -- "ERROR: product_deps has changed since the last time setup_for_development\n"
    printf -- "       was sourced: re-source before building.\n" 1>&2
    exit 2
  fi
  check_build_type="$(cmake_var CMAKE_BUILD_TYPE)"
  if [[ -n "$check_build_type" ]] && [[ "$check_build_type" != "$CETPKG_TYPE" ]]; then
    echo "ERROR: Build type has changed from $check_build_type to $CETPKG_TYPE: need clean build." 1>&2
    exit 2
  fi
  check_qual="$(cmake_var full_qualifier)"
  if [[ -n "$check_qual" ]] && [[ $(reorder_quals "$check_qual") != $(reorder_quals "$CETPKG_QUAL") ]]; then
    echo "ERROR: Qualifier has changed from \"$check_qual\" to \"$CETPKG_QUAL\": need clean build." 1>&2
    exit 2
  fi
fi

if (( ${clean_logs:-0} )); then
  report "INFO: Removing .log files from \"${CETPKG_BUILD}\""
  rm -f "${CETPKG_BUILD}"/*.log
fi

# Set install prefix from wherever we can get it.
if ! ((  ${set_install_prefix:-0} )); then
  install_prefix=${install_prefix:-${CETPKG_INSTALL}}
  install_prefix=${install_prefix:-$(cmake_var CMAKE_INSTALL_PREFIX)}
fi

if [[ -z "$install_prefix" ]]; then
  echo "INFO: unspecified or null install prefix defaulted to /dev/null." 1>&2
  install_prefix=/dev/null
elif [[ -d "${install_prefix}" ]]; then
  install_prefix_new=$(real_dir "${install_prefix}")
  if (( ${?:-1} )); then
    echo "ERROR: specified install prefix \"${install_prefix}\" cannot be converted to a physical directory location." 1>&2
    exit 1
  else
    install_prefix=${install_prefix_new}
  fi
fi

if [[ "$targets" == *install* ]] && \
   { [[ ! -d "$install_prefix" ]] || [[ ! -w "$install_prefix" ]]; }; then
  echo "ERROR: Install prefix \"${install_prefix}\" does not exist as a directory or is not writable with install target selected." 1>&2
  exit 1
fi

report "INFO: Install prefix = ${install_prefix}"
report "INFO: CETPKG_TYPE = $CETPKG_TYPE"

# Suppress messages if desired.
if (( ${quiet:-0} )); then
  exec >/dev/null
fi

# Check and set generator if not already set.
if [[ -z "$generator" ]]; then
  check_system_generator="$(cmake_sys_var CMAKE_GENERATOR)"
  if [[ -n "$check_system_generator" ]]; then
    generator_arg=-G\"${check_system_generator}\"
  fi
  case ${check_system_generator##*- } in
      Ninja)
        generator=ninja
        ;;
      "Unix Makefiles"|"")
        generator=make
        ;;
      *)
        cat 1>&2 <<EOF
WARNING: CMake's configured primary generator "${check_system_generator##*- }" is not
         recognized and is therefore not supported: buildtool cannot continue.
EOF
        exit 1
  esac
fi

if [[ "$generator" == ninja ]] && ! type -t ninja 2>&1 >/dev/null; then
  echo "ERROR: generator is specified as ninja, but ninja is not available. Product not set up?" 1>&2
  exit 1
fi

if [[ -n "$@" ]]; then
  report "Extra arguments to $generator for build stage: $@"
fi

# If we're tee-ing.
if (( ${tee:-0} )); then
  do_work "$@" 2>&1 | tee "$log"
else
  do_work "$@"
fi

# Done.
